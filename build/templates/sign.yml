# Template: Sign and validate VS Code extension artifacts
# Usage Example:
# - template: build/templates/sign.yml@self
#   parameters:
#     vsixName: black-formatter.vsix
#     workingDirectory: $(Build.SourcesDirectory)
#     signType: real
# Note: vsce CLI is invoked via 'npx vsce' (devDependency), no global install required.

parameters:
  - name: vsixName
    type: string
    default: black-formatter.vsix
  - name: manifestName
    type: string
    default: extension.manifest
  - name: signatureName
    type: string
    default: extension.signature.p7s
  - name: workingDirectory
    type: string
    default: '$(Build.SourcesDirectory)'
  - name: signType
    type: string
    default: real
  - name: verifySignature
    type: boolean
    default: true
  - name: prepareRoot
    type: boolean
    default: true
  # vsceVersion parameter removed; rely on pinned devDependency version via npx.

steps:
  # vsce CLI expected to be installed by parent pipeline; no local install here.

  - task: NuGetToolInstaller@1
    displayName: Install NuGet

  - task: NuGetCommand@2
    displayName: Restore signing packages
    inputs:
      command: restore
      restoreSolution: '$(Build.SourcesDirectory)/packages.config'
      restoreDirectory: '$(Build.SourcesDirectory)/packages'

  - task: PowerShell@2
    displayName: Pre-sign inspection
    inputs:
      targetType: inline
      script: |
        $wd = "${{ parameters.workingDirectory }}"
        $vsixName = "${{ parameters.vsixName }}"
        $manifestName = "${{ parameters.manifestName }}"
        $signatureName = "${{ parameters.signatureName }}"
        Write-Host "Pre-sign contents of working directory: $wd"
        Get-ChildItem -Recurse $wd | Select-Object FullName,Length | Format-Table -AutoSize
        $vsix = Join-Path $wd $vsixName
        if (!(Test-Path $vsix)) { Write-Error "VSIX missing: $vsix"; exit 1 }
        $manifest = Join-Path $wd $manifestName
        if (!(Test-Path $manifest)) { Write-Error "Manifest missing: $manifest"; exit 1 }
        $sig = Join-Path $wd $signatureName
        if (!(Test-Path $sig)) { Write-Warning "Signature placeholder missing (will attempt signing anyway)." }

  # Deprecated prepareRoot step removed: we now sign directly in workingDirectory by overriding BaseOutputDirectory.

  - task: MSBuild@1
    displayName: Run signing (MSBuild)
    inputs:
      solution: '$(Build.SourcesDirectory)/build/sign.proj'
      msbuildArguments: '/verbosity:detailed /bl:"${{ parameters.workingDirectory }}\\signing.binlog" /p:SignType=${{ parameters.signType }} /p:BaseOutputDirectory=${{ parameters.workingDirectory }} /p:OutDir=${{ parameters.workingDirectory }} /p:IntermediateOutputPath=${{ parameters.workingDirectory }}\\intermediate'

  # No copy-back needed; signing outputs now land directly in workingDirectory.

  - task: PowerShell@2
    displayName: Post-sign inspection
    inputs:
      targetType: inline
      script: |
        $wd = "${{ parameters.workingDirectory }}"
        $signatureName = "${{ parameters.signatureName }}"
        Write-Host "Post-sign file listing:"
        Get-ChildItem $wd -File | Select-Object Name,Length | Format-Table -AutoSize
        $sig = Join-Path $wd $signatureName
        if (Test-Path $sig) {
          Write-Host "Signature file present: $sig"
        } else {
          Write-Warning "Signature file NOT present after signing step."; exit 0
        }

  - task: PowerShell@2
    displayName: Validate signature differs from manifest (hash check)
    inputs:
      targetType: inline
      script: |
        $wd = "${{ parameters.workingDirectory }}"
        $manifest = Join-Path $wd "${{ parameters.manifestName }}"
        $signature = Join-Path $wd "${{ parameters.signatureName }}"
        if (!(Test-Path $manifest)) { Write-Error "Manifest missing for hash comparison: $manifest"; exit 1 }
        if (!(Test-Path $signature)) { Write-Error "Signature missing for hash comparison: $signature"; exit 1 }
        $manifestHash = (Get-FileHash -Algorithm SHA256 $manifest).Hash
        $signatureHash = (Get-FileHash -Algorithm SHA256 $signature).Hash
        Write-Host "Manifest SHA256 : $manifestHash"
        Write-Host "Signature SHA256: $signatureHash"
        if ($manifestHash -eq $signatureHash) {
          Write-Error "Signature file is identical to manifest (placeholder detected). Failing build."; exit 1
        } else {
          Write-Host "Hashes differ ✅ (signature not a direct copy of manifest)"
        }

  - ${{ if eq(parameters.verifySignature, true) }}:
    - task: PowerShell@2
      displayName: Verify VSIX signature
      inputs:
        targetType: inline
        script: |
          $wd = "${{ parameters.workingDirectory }}"
          $vsix       = Join-Path $wd "${{ parameters.vsixName }}"
          $manifest   = Join-Path $wd "${{ parameters.manifestName }}"
          $signature  = Join-Path $wd "${{ parameters.signatureName }}"
          Write-Host "Verifying signature:"
          Write-Host "  packagePath  : $vsix"
          Write-Host "  manifestPath : $manifest"
          Write-Host "  signaturePath: $signature"
          if (!(Test-Path $vsix)) { Write-Error "Missing VSIX: $vsix"; exit 1 }
          if (!(Test-Path $manifest)) { Write-Error "Missing manifest: $manifest"; exit 1 }
          if (!(Test-Path $signature)) { Write-Error "Missing signature file: $signature"; exit 1 }
          npx vsce verify-signature --packagePath "$vsix" --manifestPath "$manifest" --signaturePath "$signature"
          if ($LASTEXITCODE -ne 0) {
            Write-Error "vsce verify-signature failed with exit code $LASTEXITCODE"
            exit $LASTEXITCODE
          } else {
            Write-Host "vsce verify-signature succeeded ✅"
          }
